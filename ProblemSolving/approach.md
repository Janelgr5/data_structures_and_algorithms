# Problem Solving

**Resource**: How to Solve It by George Polya

## What is an Algorithm?

1. Algorithm: a process or set of steps to accomplish a certain task
2. almost everything you do in programming involes some kind of algorith
3. Foundation for being a successful problem solver and developer

## How to improve?

1. Devise a plan for solving problems
2. master common problem solving patterns

## Problem Solving

1. Understand the problem
2. Explore concrete examples
3. Break it down
4. Solve/Simplify
5. Look back and refactor

### Step 1: Understand the Problem (Restate/rephrase)

1. Can I restate the problem in my own words?
2. What are the inputs?
3. What are the outputs?
4. Can the outputs be determined from the inputs? (do you have enough info to solve the problem?)
5. How should I label the important pieces of data that are a part of the problem?

### Step 2: Concrete Examples (Examples/Edge cases)

1.  help you understand the problem better
2.  provide checks that your eventual solution works how it should.
3.  learn more information
4.  Write examples with inputs and outputs:
    1.  simple examples
    2.  complex examples
    3.  empty inputs
    4.  invalid inputs

### Step 3: Break it Down (Approach)

1. Explicitly write out the steps you need to take.
   1. forces you to think about the code you'll have to write before you write
   2. helps you catch any lingering conceptual issues or misunderstandings before you dive in and have to worry about the details (ie. sytanx)
2. Start with the skeleton of the function
3. put _//comments_ about the BASIC steps inside the function block
   4.fill in the rest as you review your examples

### Step 4: Solve/Simplify (Code)

#### Solve

1. solve the problem if you can.
2. if you cannot solve the problem solve a simpler problem.
   1. If stuck, start writing code to do the stuff you know how to do
   2. Will gain insight into the harder part of the problem.

#### Simplify

1. Find the core difficulty in what you're trying to do.
2. Temporarily ignore that difficulty
3. Write a simplified solution
4. Incorporate that difficulty back in

### Step 5: Look Back and Refactor (Test & Optimize)

1. readability vs. efficiency
2. Questions to ask yourself:
   1. Can you check the result?
   2. Can you derive the result differently?
   3. Can you use the result or method for some other problem?
   4. Can you improve the performance of your solution?
   5. Can you think other ways to refactor?
   6. How have other peple solved this problem?
